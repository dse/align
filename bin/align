#!/usr/bin/env perl
use warnings;
use strict;
use open qw(:locale);
use File::Basename qw(basename);
our $PROGNAME = basename($0);
use Getopt::Long;
use Text::Tabs qw(expand);
use List::Util qw(max);

Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    'a|after|align-after'   => sub { set_align_after(); },
    'b|before|align-before' => sub { set_align_before(); },
    'e|pattern=s'           => sub { add_pattern($_[1]); },
    'r|repeat'              => sub { set_repeat(); },
    'F|fixed-strings'       => sub { set_fixed_strings(); },
    'P|perl-regexp'         => sub { set_perl_regexp(); },
    's|skip=s'              => sub { skip_pattern($_[1]); },
    'h|help'                => sub { usage(); exit(0); },
) or die(":-(\n");

while (<>) {
    add_line($_);
    if (eof(\*ARGV)) {
        print_lines();
        clear();
    }
}

our $repeat;
our @lines;
our @instructions;
our $matcher;
our $align_after;
BEGIN {
    $repeat = 0;
    $matcher = 'fixed';
    $align_after = 0;
}
sub clear {
    @lines = ();
}
sub add_line {
    my ($line) = @_;
    $line =~ s{\R\z}{};
    $line = expand($line);
    push(@lines, { line => $line, result => '' });
}
sub print_lines {
    foreach my $instruction (@instructions) {
        $instruction->();
    }
    foreach my $line (@lines) {
        print($line->{result} . $line->{line} . "\n");
    }
}
sub set_align_before {
    push(@instructions, sub { $align_after = 0; });
}
sub set_align_after {
    push(@instructions, sub { $align_after = 1; });
}
sub add_pattern {
    my ($pattern) = @_;
    push(@instructions,
         sub {
             $pattern = $matcher eq 'perl' ? qr{$pattern} : qr{\Q$pattern\E};
             swallow($pattern);
             align();
         });
}
sub skip_pattern {
    my ($pattern) = @_;
    push(@instructions,
         sub {
             $pattern = $matcher eq 'perl' ? qr{$pattern} : qr{\Q$pattern\E};
             swallow($pattern);
         });
}
sub set_repeat {
    $repeat = 1;
}
sub set_fixed_strings {
    $matcher = 'fixed';
}
sub set_perl_regexp {
    $matcher = 'perl';
}
sub swallow {
    my ($pattern, %args) = @_;
    foreach my $line (@lines) {
        if ($line->{line} =~ $pattern) {
            if ($align_after) {
                $line->{result} .= $` . $&;
                $line->{line} = $';
            } else {
                $line->{result} .= $`;
                $line->{line} = $& . $';
            }
            $line->{match} = 1;
        } else {
            $line->{match} = 0;
        }
    }
}
sub align {
    my @matching_lines = grep { $_->{match} } @lines;
    my $width = max map { length($_->{result}) } @matching_lines;
    foreach my $line (@matching_lines) {
        $line->{result} = sprintf('%-*s', $width, $line->{result});
    }
}
