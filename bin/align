#!/usr/bin/env perl
use warnings;
use strict;
use open qw(:locale);
use File::Basename qw(basename);
our $PROGNAME = basename($0);
use Getopt::Long;
use Text::Tabs qw(expand);
use List::Util qw(max);

Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    'a|after|align-after'   => sub { set_align_after(); },
    'b|before|align-before' => sub { set_align_before(); },
    'e|pattern=s'           => sub { add_pattern($_[1]); },
    'r|repeat'              => sub { set_repeat(); },
    'F|fixed-strings'       => sub { set_fixed_strings(); },
    'P|perl-regexp'         => sub { set_perl_regexp(); },
    's|skip=s'              => sub { skip_pattern($_[1]); },
    'h|help'                => sub { usage(); exit(0); },
) or die(":-(\n");

while (<>) {
    add_line($_);
    if (eof(\*ARGV)) {
        print_lines();
        reset();
    }
}

our $repeat;
our @lines;
our @instructions;
our $matcher;
our $align_after;
BEGIN {
    reset();
}
sub reset {
    # after each file, instructions are executed, then this is
    # executed.
    $repeat = 0;
    @lines = ();
    @instructions = ();
    $matcher = 'perl';
    $align_after = 0;
}
sub add_line {
    my ($line) = @_;
    $line =~ s{\R\z}{};
    $line = expand($line);
    push(@lines, { line => $line, result => '' });
}
sub print_lines {
    foreach my $instruction (@instructions) {
        $instruction->();
    }
    foreach my $line (@lines) {
        print($line->{result} . $line->{line} . "\n");
    }
}
sub set_align_before {
    push(@instructions, sub { $align_after = 0; });
}
sub set_align_after {
    push(@instructions, sub { $align_after = 1; });
}
sub add_pattern {
    my ($pattern) = @_;
    $pattern = $matcher eq 'perl' ? qr{$pattern} : qr{\Q$pattern\E};
    print("add     $pattern\n");
    push(@instructions, sub { swallow($pattern); });
}
sub skip_pattern {
    my ($pattern) = @_;
    $pattern = $matcher eq 'perl' ? qr{$pattern} : qr{\Q$pattern\E};
    print("skip    $pattern\n");
    push(@instructions, sub { swallow($pattern, skip => 1); });
}
sub set_repeat {
    push(@instructions, sub { $repeat = 1; });
}
sub set_fixed_strings {
    $matcher = 'fixed';
}
sub set_perl_regexp {
    $matcher = 'perl';
}
sub swallow {
    my ($pattern, %args) = @_;
    print("swallow $pattern\n");
    my @matching;
    foreach my $line (@lines) {
        if ($line->{line} =~ $pattern) {
            $line->{pre} = $`;
            $line->{match} = $&;
            $line->{post} = $';
            push(@matching, $line);
        } else {
            delete $line->{pre};
            delete $line->{match};
            delete $line->{post};
        }
    }
    if ($args{skip}) {
        foreach my $line (@matching) {
            $line->{result} .= $line->{pre} . $line->{match};
            $line->{line} = $line->{post};
        }
    } elsif ($align_after) {
        foreach my $line (@matching) {
            $line->{result} .= $line->{pre} . $line->{match};
            $line->{line} = $line->{post};
        }
        align();
    } else {
        foreach my $line (@matching) {
            $line->{result} .= $line->{pre};
        }
        align();
        foreach my $line (@matching) {
            $line->{result} .= $line->{match};
            $line->{line} = $line->{post};
        }
    }
}
sub align {
    my @matching = grep { defined $_->{match} } @lines;
    my $width = max map { length($_->{result}) } @matching;
    foreach my $line (@matching) {
        $line->{result} = sprintf('%-*s', $width, $line->{result});
    }
}
